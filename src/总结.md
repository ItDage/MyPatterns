##策略模式
1. 需求:假设某个网站销售各种书籍，对初级会员没有提供折扣，对中级会员提供每本10%的促销折扣，对高级会员提供每本20%的促销折扣。折扣是根据以下的3个算法中的1个进行的：
	+ 算法1：对初级会员没有提供折扣。
	+ 算法2：对中级会员提供10%的促销折扣。
	+ 算法3：对高级会员提供20%的促销折扣。
2. UML图
	+ ![](https://i.imgur.com/OFfDdBU.png)
3. 定义:它定义了算法家族,分别封装起来,让它们之间可以相互替换,此模式让算法的变化,不会影响到使用算法的客户。
4. 策略模式使得算法可以在不影响到客户端的情况下发生变化。
###优点
1. 通过策略类的等级结构来管理算法族。
2. 避免使用将采用哪个算法的选择与算法本身的实现混合在一起的多重条件(if-else if-else)语句
###缺点
1. 客户端必须要知道所有的策略类,并自行决定使用哪一个策略类。
2. 由于策略模式把每个算法的具体实现都单独封装成类,针对不同的情况生成的对象就会变得很多。
###优化
1. 可以使用简单工厂 + 策略模式优化main方法

##状态模式
1. 定义: 当一个对象的内在状态改变时允许改变其行为,这个对象看起来像是改变了其类。状态模式的好处是将与特定状态相关的行为局部化,并且将不同状态的行为分割开来。这样可以消除庞大的条件分支语句,状态模式通过把各种状态转移逻辑分布到State的子类之间,来减少相互间的依赖。
2. UML图
	+ ![](https://i.imgur.com/yPl73TA.png)
3. 应用场景: 主要解决的是当控制一个对象的状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中,可以把复杂的判断逻辑简化。**当一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为时,就可以考虑使用状
##装饰模式
1. 优点:把类中的装饰功能从类中搬移去除,这样可以简化原有的类。有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑
2. UML图![](https://i.imgur.com/WZWrUVV.png)
3. Component是定义的一个对象接口,可以给这些对象动态地添加职责。ConcreteComponent是定义的一个具体的对象,也可以给这个对象添加一些职责。Decorator,装饰抽象类,继承了Component,从外类来扩展Component类的功能,但对于Component来说,是无需知道Decorator存在的。至于ConcreteDecorator就是具体的装饰对象,起到了给Component添加职责的功能。
##代理模式
1. 为什么要使用代理模式
	+ 中介隔离作用:在某些情况下,一个客户类不想或者不能直接引用一个委托对象,而代理类对象可以在客户类和委托对象之间起到中介的作用,其特征是代理类和委托类实现相同的接口
	+ 开闭原则,增加功能:代理类除了是客户类和委托类的中介之外,我们还可以通过给代理类增加额外的功能来扩展委托类的功能,这样做我们只需要修改代理类而不需要再修改委托类,符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类,以及事后对返回结果的处理等。代理类本身并不真正实现服务,而是通过调用委托类的相关方法来提供特定的服务。真正的业务功能还是由委托类来实现,但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能,我们可以使用代理类来完成,而没必要打开已经封装好的委托类。
2. UML图![](https://i.imgur.com/JEUEoJM.png)